
| 符号   | 名称                          | 作用位置        | 用途                     |
| ---- | --------------------------- | ----------- | ---------------------- |
| `*`  | 可迭代对象解包（iterable unpacking） | 函数调用 / 赋值   | 把**列表、元组、集合、字符串**等“拆开” |
| `**` | 字典解包（dictionary unpacking）  | 函数调用 / 函数定义 | 把**字典**里的键值对“拆开”       |
可以看到`**`是对字典解包，就是拆分键值对。

# `*的用途`
通过下面的例子，可以了解到`*`不仅仅可以对可迭代对象进行解包，还可以进行"智能"收包。
### 1. 函数调用时“拆”列表/元组
```python
def add(a, b, c):
    return a + b + c

nums = [1, 2, 3]
print(add(*nums))   # 等价于 add(1, 2, 3)  → 6
```
### 2. 定义函数时“收”可变位置参数
```python
def foo(a, *args):
    print(a)        # 第一个参数
    print(args)     # 其余所有位置参数组成的元组

foo(10, 20, 30, 40)
# 输出：
# 10
# (20, 30, 40)
```
### 3. 赋值语句里“拆”可迭代对象
```python
a, *middle, last = [1, 2, 3, 4]
print(a)      # 1
print(middle) # [2, 3]
print(last)   # 4
```

# `**的用途`
`**` 在 Python 里只有两种合法的“身份”，各自出现在两个固定位置，用途非常清晰：

|出现位置|写法示例|官方叫法|通俗作用|
|:--|:--|:--|:--|
|**函数定义形参列表**|`def f(**kw)`|“可变关键字形参”|把调用者传进来的**多余关键字实参**收集成**一个字典**，变量名通常叫 `kwargs`。|
|**函数调用实参列表**|`f(**dict_obj)`|“关键字参数解包”|把字典里的键值对一次性拆成关键字实参传给函数。|

也就是说：  
• **在 `def` 里收包，在调用时拆包**——除此之外，`**` 在任何其他上下文都会直接抛 `SyntaxError`。
### 1. 收包：在函数定义里
```python
def api_call(method, path, **params):
    # params 是一个字典，里面装着所有额外传进来的关键字参数
    print(method, path, params)

api_call('GET', '/user', token='abc', limit=10)
# 输出：GET /user {'token': 'abc', 'limit': 10}
```

---

### 2. 拆包：在函数调用里
```python
def api_call(method, path, token, limit):
    ...

args = {'token': 'abc', 'limit': 10}
api_call('GET', '/user', **args)   # 等价于 api_call('GET', '/user', token='abc', limit=10)
```
### 3. 同时出现：既收又拆
```python
def wrapper(**kw):
    return real_func(**kw)   # 先把多余关键字收进来，再全部转交给 real_func
```
### ⚠️ 注意

• **不能**在赋值语句、列表推导式、除函数定义/调用之外的任何地方用 `**`；  
• 形参列表里 `**` 只能出现一次，且必须位于所有普通形参和 `*args` 之后。

一句话记忆：**`**` 只干两件事：在 `def` 里“收字典”，在调用时“拆字典”。**