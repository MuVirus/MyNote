# 前言

为什么我会出这一系列课？

# 布置环境

## Epic 的下载 & 通过Epic 下载 Unreal 非源码版本

## 搭建 c++ 环境（下载 VS 和 Rider）

注意，必须先下载VS，弄好整个编译环境后在下载rider，否则rider下了也没用，但是推荐还是用rider，因为比vs真的太好用了。但是本教程只会用 VS

VS2022安装选项要有：

1. .Net桌面开发
2. 使用c++进行桌面开发
3. 使用c++进行游戏开发
4. Windows 11 SDK

## 下载 Git

## 下载 源码版 Unreal

# Unreal c++ 基础

## 注释

```cpp
// 这是单行注释

/* 
    这是
    多行注释  -game -log -nullrhi
*/
```

## Unreal 如何打 Log

`UE_LOG(LogTemp, Error, TEXT("This is i: %i"), i);` 输出在控制台的 log

1. LogTemp，是模块
2. Error 是日志等级
    - Log
    - Display
    - Warning：警告，这时候日志的字体为黄色
    - Error：错误，这时候日志的字体为红色，这个一般为最高等级
3. TEXT则就是日志内容，我们如果想打印信息就得用占位符，比如示例中的 i
    - %s：打印字符串
    - %i：打印整数
    - %f：打印浮点数

`GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("Health is low!"));` 打印到游戏屏幕的 log

## 变量类型 与 数据类型

### 布尔型（bool型）

```cpp
// bool：用于表示布尔值，只能取true或false
bool bIsOKTrue = true;  // true 为真
bool bIsOKFalse = false;  // false 为假
```

### 字符型

1. 原生 c++ 字符串
    
    - `std::string`
2. Unreal c++ 字符类型
    
    - FString
        
        ```cpp
        // FString：用于表示一段文本信息, 更倾向于用于字符串的动态操作(拼接、修改、解析)
        FString MyStr = "MyStr";
        UE_LOG(LogTemp, Log, TEXT("This is Str: %s"), *MyStr);
        ```
        
    - FName
        
        ```cpp
        // FName：用于引擎内部的标识 (资源名、骨骼名)
        FName MyName = "XiaoMing";
        UE_LOG(LogTemp, Log, TEXT("This is Name: %s"), *MyName.ToString());  // 需要将FName 转换为 FString才能在日志打印出来
        ```
        
    - FText
        
        ```cpp
        // FText：用于显示给玩家看的一切文本，支持本地化(翻译)。
        #define LOCTEXT_NAMESPACE "MyGameWidgets"
        	FText WelcomeMessage = LOCTEXT("WelcomeMsg", "Welcome to our game!");
        	FText QuitButtonLabel = LOCTEXT("QuitBtn", "Quit");
        #undef LOCTEXT_NAMESPACE
        ```
        
        ```cpp
        FText MyText = FText::FromString("This is MyText");
        UE_LOG(LogTemp, Log, TEXT("This is Text: %s"), *MyText.ToString());  // 输出日志也需要转换成 FString
        ```
        

### 整型

```cpp
int i = -1;  // int：用于表示整数，通常占用4个字节。有符号
int32 i32 = 1;  // 有符号
int64 i64 = 1;  // 有符号
uint8 ui8 = 2;  // 无符号，也就是说只有正整数
uint32 ui32 = 11231;  // 无符号
uint64 ui64 = 1123123321;  // 无符号
uint32 Myui32 = -1;
uint64 Myui64 = -1;

UE_LOG(LogTemp, Error, TEXT("This is i: %i, i32: %i, i64: %i, ui8: %i, ui32: %i, ui64: %i, Myui32: %i, Myui64: %i, Myui32: %lu, Myui64: %llu"), i, i32, i64, ui8, ui32, ui64, Myui32, Myui64, Myui32, Myui64);
```

### 浮点型

```cpp
float MyFloat = 0.1f;  // float 只有32位，最常用
float MyFloat2 = 0.1;
double MyDouble = 0.1;  // double 有64位，范围更多
UE_LOG(LogTemp, Log, TEXT("This is Float1: %f, Float2: %f, MyDouble: %lf, Float1: %.1f"), MyFloat, MyFloat2, MyDouble, MyFloat);
```

### 无类型

```cpp
void
```

### 变量定义

```cpp
int i = 20;
<数据类型> <变量名> = 值;
```

## 代码逻辑语句

### 判断

1. **判断语句：如果…那么…**
    
    - if, else if, else
        
        ```cpp
        int MyInt = 1;
        if (MyInt == 1)
        {
            UE_LOG(LogTemp, Display, TEXT("MyInt = 1"));
        }
        else if (MyInt == 2)
        {
            UE_LOG(LogTemp, Display, TEXT("MyInt = 2"));
        }
        else
        {
            UE_LOG(LogTemp, Display, TEXT("else"));
        }
        ```
        
    - 比较运算符：== (等于), != (不等于), >, <, >=, <=
        
        ```cpp
        int MyInt = 1;
        if (MyInt != 1)
        {
            UE_LOG(LogTemp, Display, TEXT("MyInt != 1"));
        }
        else 
        {
            UE_LOG(LogTemp, Display, TEXT("else"));
        }
        ```
        
    - 逻辑运算符：&& (与), || (或), ! (非)
        
        ```cpp
        int MyInt = 1;
        bool MyBool = true;
        if (MyInt == 1 && MyBool)
        {
            UE_LOG(LogTemp, Display, TEXT("MyInt == 1 && MyBool"));
        }
        
        if (MyInt != 1 && MyBool)
        {
            UE_LOG(LogTemp, Display, TEXT("MyInt != 1 && MyBool"));
        }
        
        if (MyInt != 1 || MyBool)
        {
            UE_LOG(LogTemp, Display, TEXT("MyInt != 1 || MyBool"));
        }
        
        if (!MyBool)
        {
            UE_LOG(LogTemp, Display, TEXT("!MyBool"));
        }
        ```
        
2. **Switch**
    
    ```cpp
    int i = 1;
    switch (i)
    {
        case 0:
            {
                UE_LOG(LogTemp, Display, TEXT("MyInt == 0"));
                break;  // 结束
            }
        case 1:
            {
                UE_LOG(LogTemp, Display, TEXT("MyInt == 1"));
                break;
            }
        default:
            {
                UE_LOG(LogTemp, Display, TEXT("MyInt == default"));
                break;
            }
    }
    ```
    

### 循环

1. for
    
    ```cpp
    for (int i = 0; i < 9; ++i)
    {
        UE_LOG(LogTemp, Log, TEXT("This is i: %i"), i);
    }
    ```
    
2. while
    
    需要注意的是防止死循环
    
    ```cpp
    int i = 0;
    while (i < 9)
    {
        UE_LOG(LogTemp, Log, TEXT("This is i: %i"), i);
        ++i;
    }
    ```
    
3. 死循环
    
    ```cpp
    int i = 0;
    while (i < 9)
    {
    	UE_LOG(LogTemp, Log, TEXT("This is i: %i"), i);
    }
    ```
    
4. 跳过（continue）
    
    ```cpp
    for (int i = 0; i < 9; ++i)
    {
        if (i == 3)
            continue;
        UE_LOG(LogTemp, Log, TEXT("This is i: %i"), i);
    }
    ```
    
5. 结束循环（break）
    
    ```cpp
    for (int i = 0; i < 9; ++i)
    {
        if (i == 3)
            break;
        UE_LOG(LogTemp, Log, TEXT("This is i: %i"), i);
    }
    ```
    

## 数据结构

### 数组

1. 原生 c++ 数组
    
    - 固定大小，在声明时就确定了。
    - `int MyNumbers[5] = {10, 20, 30, 40, 50};`
    - 通过索引访问：`MyNumbers[0]` 的值是10。 Index（索引）都是从0开始的
2. Unreal c++ 数组
    
    - 更强大、更常用！大小可以在运行时改变。
        
    - 声明：`TArray<int32> MyIntArray;`
        
    - 常用操作：
        
        ```cpp
        TArray<FString> FruitList;
        FruitList.Add(TEXT("Apple"));     // 添加元素
        FruitList.Add(TEXT("Banana"));
        FruitList.Remove(TEXT("Apple")); // 按值移除
        FruitList.RemoveAt(0);           // 按索引移除
        
        int32 Count = FruitList.Num();   // 获取元素数量
        
        // 遍历数组
        for (FString Fruit : FruitList)
        {
            UE_LOG(LogTemp, Log, TEXT("Fruit: %s"), *Fruit);
        }
        ```
        

### 字典

**用于存储键值对 (Key-Value)，通过唯一的“标签”（Key）快速找到对应的“物品”（Value）。**

1. 原生 c++ 字典
    
    - `std::map<std::string, int> ScoreMap`
2. Unreal的字典: TMap
    
    - 在UE中性能更高，与引擎结合更好。
        
    - 声明：`TMap<FName, int32> PlayerScores;`
        
    - 常用操作：
        
        ```cpp
        TMap<FString, int32> AgeMap;
        AgeMap.Add(TEXT("Alice"), 25);   // 添加键值对
        AgeMap.Add(TEXT("Bob"), 30);
        
        // 通过Key查找Value
        int32* BobsAge = AgeMap.Find(TEXT("Bob"));
        if (BobsAge != nullptr)
        {
            UE_LOG(LogTemp, Log, TEXT("Bob's age is: %d"), *BobsAge);
        }
        
        AgeMap.Remove(TEXT("Alice")); // 移除
        ```
        

## 函数

将一段执行特定任务的代码打包，并给它一个名字，方便重复调用。

### 函数的结构

```cpp
// 返回值类型 函数名(参数类型1 参数名1, 参数类型2 参数名2, ...)
// {
//     // 函数体: 执行具体任务的代码
//     return 返回值; // 如果返回值类型不是void，则必须有return
// }

// 示例：一个计算加法的函数
int Add(int A, int B)
{
    int Result = A + B;
    return Result;
}

// 示例：一个没有返回值的打印函数
void PrintMessage(FString Message)
{
    UE_LOG(LogTemp, Log, TEXT("%s"), *Message);
}
```

## h / cpp 文件

1. .h 文件又叫头文件，用来声明
    
    ```cpp
    // xxx.h
    int Add(int A, int B);
    ```
    
2. .cpp 文件又叫 cpp文件，用来定义
    
    ```cpp
    int Add(int A, int B)
    {
        return A + B;
    }
    ```
    
3. 如果你需要引入其他你写的头文件就 `include "xxxx.h"`即可，注意不能 include cpp文件，如果你想引入c++自己的头文件，则`include <windows.h>`
    
4. 你也可以直接在头文件直接定义一个函数，也是可以的。反过来一样的，你也可以在cpp文件声明一个函数，但是这样子就没办法在其他的文件去调用这个函数了
    

## 内存概念

### 什么是内存 (Memory): 计算机的“草稿纸”

- 内存是计算机用于临时存储数据和程序指令的地方。可以想象成一大排带编号的储物柜。
    
- **栈 (Stack):** 一块小而快的内存，用于存放函数内的局部变量。函数调用结束，里面的东西就自动清空。管理简单高效。
    
    栈其实比如我们的函数里的参数，局部变量都会存放进栈
    
- **堆 (Heap):** 一块大得多的内存，用于存放需要长期存在的数据（比如游戏世界里的角色）。需要我们自己去申请和释放，管理不当容易出问题。
    

### 指针

- 指针本身也是一个变量，但它不存数据，而是存另一个变量的**内存地址（储物柜编号）**。
- 通过指针，我们可以间接地访问和修改它指向的那个变量。

```cpp
int32 Health = 100;
int32* HealthPtr = &Health; // HealthPtr 存储了 Health 的地址 (&是取地址符)

// 修改Health的值
Health = 90; 

// 通过指针修改Health的值
*HealthPtr = 80; // * 是解引用符，表示“访问这个地址里的东西”

// 此时，Health 的值是 80
UE_LOG(LogTemp, Log, TEXT("Health is now: %d"), Health);
```

### 引用

- 引用是一个已存在变量的别名，操作引用就等于操作原变量。
- 它比指针更安全、更简单，但没那么灵活。

```cpp
int32 Score = 500;
int32& ScoreRef = Score; // ScoreRef 就是 Score 的一个外号

ScoreRef = 600; // 修改外号

// 此时，Score 的值也是 600
UE_LOG(LogTemp, Log, TEXT("Score is now: %d"), Score);
```

### 内存泄漏

- 在堆上申请了内存（比如 new 了一个对象），但用完之后忘记释放(delete)，这块内存就丢失了，谁也用不了。就像从图书馆借了书不还，书越来越少。
- 在Unreal中，UObject系统极大地解决了这个问题 ，通过垃圾回收(GC)自动管理内存，我们通常不需要手动 new 和 delete。但是，还是会有内存泄漏的问题的，如果你的编码习惯不好

## 变量作用域及常量

### 变量作用域

变量能“存活”和被访问的区域。通常由大括号 {} 界定。

```cpp
void MyFunction()
{
    int LocalVar = 10; // 这是一个局部变量，只在 MyFunction 内有效
}
// 在 MyFunction 外面，访问不到 LocalVar
```

### 常量

一个值不能被修改的变量，用 const 关键字声明。

```cpp
const float Pi = 3.14159f;
```

**static**

static 修饰不同的东西会有不同的效果，但是终归影响的其实就是他的生命后期，作用域，最常见是用于修饰函数，成员函数，这样无论哪里都可以直接调用

1. static 修饰局部变量
    - 存放原本从栈区变成了静态存储区
    - 生命周期原本从包含语句模块结束变成了延续到整个程序结束
    - 作用域不发生变化
2. static 修饰全局变量
    - static全局变量会存在静态存储区
    - 生命周期会延续到整个程序结束
    - 作用域从原本的全文件共享，变成了定义文件共享
3. static 修饰函数
    - 跟全局变量类似，作用域发生了改变
4. static 修饰成员变量
    - 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和 private、public、protected 访问规则
    - 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象，且只能该变量只能被初始化一次，不能在类的构造函数中对静态成员变量进行初始化
    - 静态成员变量可以作为成员函数的参数，而普通成员变量不可以
    - 静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用
5. static 修饰成员函数
    - 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 `this` 指针。静态成员函数做为类作用域的全局函数
    - 静态成员函数不能声明成 virtual function、const funciton、volatile function
6. static 对象
    - 静态对象的生存周期为整个程序的生命周期，而非静态对象的生命周期只存在于某个循环中

## 类

### 类的基本概念

什么是类与对象  
成员变量与成员函数  
class 关键字  
头文件 .h 与源文件 .cpp 的分工

### 访问控制与封装

public：公共接口定义  
private：私有数据保护  
protected：继承链中的可见性  
Getter 与 Setter 函数的设计模式  
封装的意义：数据安全与维护性

### 对象的生命周期

构造函数：默认构造、带参构造与重载  
初始化列表：语法、效率优势与必要场景  
析构函数：资源释放的时机  
RAII 资源获取即初始化理念  
栈上对象 vs 堆上对象（new 与 delete）  
this 指针的本质与用法

### 继承与多态

基类与派生类的关系  
继承的类型：public 继承的使用  
virtual 虚函数：多态的核心  
override 关键字：确保重写的安全性  
纯虚函数与抽象类：接口的定义  
虚析构函数：防止内存泄漏的必要性

## 结构体

1. 什么是结构体
    
    用于将多个不同类型的变量打包成一个单一的、有意义的类型。
    
2. 原生c++ 声明结构体
    
    ```cpp
    struct FPlayerInfo
    {
        std::string PlayerName;
        int Health;
        bool bIsAlive;
        
        // 构造函数 (一种特殊的成员函数，用于初始化)
        FPlayerInfo(std::string InName)
        {
            PlayerName = InName;
            Health = 100;
            bIsAlive = true;
        }
    
        // 成员函数 (方法)
        void TakeDamage(int Damage)
        {
            if (bIsAlive)
            {
                Health -= Damage;
                if (Health <= 0)
                {
                    Health = 0;
                    bIsAlive = false;
                    std::cout << PlayerName << " has been defeated!" << std::endl;
                }
            }
        }
    };
    ```
    
3. Unreal c++ 声明结构体
    
    ```cpp
    #include "MyStruct.generated.h" // 必须包含 .generated.h 文件
    
    USTRUCT(BlueprintType) // BlueprintType让蓝图也能使用这个结构体
    struct FItemData
    {
        GENERATED_BODY() // UE结构体必须的宏
    
        UPROPERTY(EditAnywhere, BlueprintReadWrite) // 让这个变量在编辑器和蓝图里可见可编辑
        FString Name;
    
        UPROPERTY(EditAnywhere, BlueprintReadWrite)
        int32 ID;
    
        UPROPERTY(EditAnywhere, BlueprintReadWrite)
        float Weight;
        
        FItemData()
        {
            Name = TEXT("Default Item");
            ID = -1;
            Weight = 1.0f;
        }
        
        UFUNCTION(BlueprintPure, Category = "Item Functions")
        bool IsValid() const
        {
            return ID != -1 && !Name.IsEmpty();
        }
    };
    ```
    

## Unreal中的类

### UE C++ 编程环境基础

CoreMinimal.h 是包含虚幻引擎核心类型如 FString、TArray 和数学库的轻量级头文件，用于优化编译速度。  
.generated.h 文件由 Unreal Header Tool UHT 生成，包含了反射系统所需的样板代码。  
在源文件的 include 列表中，.generated.h 必须始终作为最后一个被包含的头文件，否则会导致编译错误。  
前缀 A 代表 Actor，即所有可以放置在关卡中的对象的基类。  
前缀 U 代表 UObject，即所有受垃圾回收和反射系统管理但无法直接放置在关卡中的对象的基类。  
前缀 F 代表 Struct 或普通的 C++ 类，通常用于数据结构或不受垃圾回收管理的工具类。  
前缀 I 代表 Interface，用于定义抽象接口类。  
前缀 E 代表 Enum，用于定义枚举类型。

### 核心基类体系

UObject 是虚幻引擎对象系统的基石，提供垃圾回收、序列化、反射和网络复制的基础支持。

1. 什么垃圾回收
    
    ```cpp
    Tank* InTank = new Tank;
    ```
    
    这个 InTank 他什么地方都没有被引用到，这个就说明是一个垃圾，需要把他回收掉，也就是内存空间释放出来
    
    垃圾回收其实是很吃资源的, c / c++ 都是没有的垃圾回收的，所以需要程序员自己手动释放内存，但是记住unreal是有垃圾回收的，因为unreal是魔改c++
    
2. 反射
    
    我们写的 c++ 代码 对于蓝图而言是不知道的，所以我们要反射到蓝图里面
    
3. 网络复制
    
    自然就是一些比如生命值，你要去复制到服务器 客户端双通
    

AActor 继承自 UObject，是所有可以在场景中拥有变换信息 Transform 的对象的基类，支持挂载组件。

1. 比如一个墙壁，一个箱子，他需要放在场景中，并且他有变换信息，比如他的位置，他的旋转

UActorComponent 是用于定义可复用功能的模块化基类，可以挂载到 Actor 上，分为单纯逻辑组件和拥有变换的 SceneComponent。

1. 比如 箱子有生命值 你可以破坏它，所以你写了一个继承于ActorComponent的HealthComponent，来管理生命值，并且把他挂在Actor上，这样就代表这个Actor有生命值

Pawn 是可以被 Controller 控制的 Actor，代表了游戏中的可操控代理，如载具或生物。

Character 继承自 Pawn，专门为直立行走的生物设计，内置了 CharacterMovementComponent 以处理复杂的移动逻辑和网络同步，并包含胶囊体碰撞。

### 反射系统与宏

UCLASS 宏用于标记一个类，使其能够被虚幻引擎的反射系统识别，从而支持垃圾回收和蓝图交互。  
GENERATED_BODY 宏必须放置在类定义的第一行，它负责注入 UHT 生成的反射代码和样板函数。

UPROPERTY 宏用于修饰成员变量，使其在编辑器中可见、可被序列化或被垃圾回收系统追踪引用。

EditAnywhere 允许在编辑器的主面板和实例细节面板中修改该变量的值。

VisibleAnywhere 允许在编辑器中看到该变量，但无法修改其本身，通常用于组件指针，允许编辑组件内部属性但禁止替换组件实例。

BlueprintReadWrite 允许该变量在蓝图图表中既可以被获取 Get 也可以被设置 Set。

BlueprintReadOnly 限制该变量在蓝图中只能作为输入节点被获取，无法被修改。

Category 关键字用于在编辑器的细节面板或蓝图右键菜单中对属性和函数进行分组归类，保持界面整洁。

UFUNCTION 宏用于修饰成员函数，使其能够被反射系统识别，从而支持在蓝图中调用或绑定委托。

BlueprintCallable 将 C++ 函数暴露为蓝图节点，拥有执行引脚，可以被蓝图逻辑流调用。

BlueprintPure 将 C++ 函数暴露为无执行引脚的数据节点，通常用于获取状态或计算数值，不会改变对象状态。

BlueprintNativeEvent 允许 C++ 提供一个默认实现函数名后缀为 Implementation，蓝图可以选择重写它，也可以直接使用 C++ 的默认逻辑。

BlueprintImplementableEvent 在 C++ 中只进行声明而不写实现，意在强制由蓝图提供具体逻辑，C++ 负责在适当时机调用。

### 接口与通信

UInterface：解决多重继承问题的方案

代理 Delegates：C++ 中的事件绑定与广播

### 进阶细节

static 静态成员：属于类而非对象的数据

const 成员函数：承诺不修改对象状态

friend 友元：打破封装的特殊场景

inline 函数

### 智能指针

- **问题背景：** 我们之前提到，在堆(Heap)上用 new 创建了对象，就必须在某个地方用 delete 来销毁它。这个过程完全靠程序员手动管理，极其容易出错。忘记 delete 会导致内存泄漏；对同一个指针 delete 两次会导致程序崩溃；访问一个已经被 delete 的指针（悬挂指针）也是灾难性的。
- **解决方案：** 智能指针！它是一个C对象（一个“管家”），内部包装了一个原始指针（一把“钥匙”）。这个管家对象利用C的作用域规则，在自己被销毁时（例如函数结束、对象生命周期结束），自动地、确定地 delete 它所管理的指针。

#### 管理 `UObject` 及其派生类 (如 `AActor`, `UActorComponent`)

`UObject` 是Unreal引擎的核心，所有继承自它的对象都由**垃圾回收 (Garbage Collection, GC)** 系统统一管理生命周期。我们要做的是正确地“配合”GC工作。

|指针类型|何时使用？(最佳实践)|
|---|---|
|`TObjectPtr<T>`|【首选/默认】 任何时候你需要一个指向UObject的指针，都应该优先使用它。无论是成员变量还是局部变量。<br><br>核心优势： 当它指向的UObject被销毁时，`TObjectPtr`会自动变为空指针 (`nullptr`)，彻底杜绝了悬挂指针崩溃的风险。|
|`UPROPERTY()` 宏|当你需要防止一个UObject被GC回收时，必须用`UPROPERTY()`来标记持有它的指针。<br><br>黄金组合： `UPROPERTY() TObjectPtr<T>`。`UPROPERTY`负责“保活”，`TObjectPtr`负责“安全访问”。|
|`TWeakObjectPtr<T>`|当你需要引用一个UObject，但不想阻止它被GC回收时使用。<br><br>核心用途： 避免循环引用。例如，一个子Actor想引用它的父Actor，但不希望因为这个引用导致父Actor永远无法被销毁。|
|TSubclassOf<T>|【极其常用】 当你需要一个变量来持有某个蓝图或C++类本身，以便后续用它来生成(Spawn)新的实例时。<br><br>核心优势： 类型安全。它在编辑器和编译期就能保证你赋给这个变量的，必须是指定的基类 T 或其子类。|

---

#### 阵营二：管理非 `UObject` 的普通 C++ 类

对于那些你自己创建的、不继承自 `UOject` 的普通C++类（例如 Slate UI 的逻辑类、自定义的数据管理器等），GC系统完全不管它们。

这时，我们就需要请出C++的传统智能指针来手动管理它们的生命周期。

说是c++的传统指针，其实也是Unreal在于基础上自己封装的

|指针类型|所有权模型|何时使用？|
|---|---|---|
|**`TSharedPtr<T>` / `TSharedRef<T>`**|共享所有权 (Shared Ownership)|【最常用】 当一个对象需要被多个其他对象共同拥有和管理时。它使用引用计数，当最后一个所有者消失时，对象被自动销毁。`TSharedRef`是保证永不为空的版本。<br><br>核心用途：Slate UI, 异步任务, 共享的数据管理器。|
|**`TWeakPtr<T>`**|无所有权 (Non-owning Observer)|当你需要“观察”一个由`TSharedPtr`管理的对象，但不想成为它的所有者（即不想增加引用计数）时。<br>核心用途： 缓存指针，以及打破`TSharedPtr`之间的循环引用。|
|**`TUniquePtr<T>`**|独占所有权 (Exclusive Ownership)|当一个对象在任何时候都只能有一个唯一的所有者时。它非常轻量，性能接近原始指针，但不能被复制，只能被移动 (Move)。<br><br>核心用途：工厂函数的返回值，Pimpl惯用法。|

### 最终决策流程图

当你需要一个指针时，这样问自己：

1. 我要指向的对象是 `UObject` 吗？
    - 是 -> 进入 UObject阵营
        - 我需要阻止它被GC回收吗？
            - 是 -> 使用 `UPROPERTY() TObjectPtr<T>`
            - 否 -> 只是临时引用或观察？*
                - 可能会产生循环引用吗？ -> 使用 `TWeakObjectPtr<T>`
                - 不会 -> 使用 `TObjectPtr<T>`
    - 否 -> 进入 非UObject阵营
        - 这个对象需要被多个地方共享吗？
            - 是 -> 使用 `TSharedPtr<T>` (以及配套的 `TWeakPtr`)
            - 否 -> 它只有一个主人吗？ -> 使用 `TUniquePtr<T>`

# 匿名函数 (Lambda 表达式)

1. 什么是 Lambda？  
它本质上是一个没有名字的内联函数。你可以把它当成一个“用完即走”的逻辑包。  
传统方式：需要在头文件声明函数，在 .cpp 实现函数，然后再调用它。  
Lambda 方式：直接在代码执行的地方写下逻辑，无需为了一个简单的功能去污染头文件。

2. 语法解构：它是怎么长出来的？  
一个标准的 Lambda 表达式长这样：  
[捕获列表] (参数列表) -> 返回值类型 { 函数体 }

[] 捕获列表 (Capture List)：这是 Lambda 的灵魂。它决定了 Lambda 内部能访问外部的哪些变量。  
() 参数列表：和普通函数一样，用来接收输入。  
{} 函数体：具体的逻辑代码。

3. 核心机制：捕获列表 [] 详解  
在 Lambda 里，外面的变量不是想用就能用的，你必须“捕获”进来。

|写法|含义|场景|
|---|---|---|
|[]|不捕获|内部只能用传入的参数，不能用外面的局部变量。|
|[=]|按值捕获所有|把外部所有变量拷贝一份进来（只读）。|
|[&]|按引用捕获所有|直接操作外部变量的内存地址（在 UE 中慎用，容易导致悬空指针崩溃）。|
|[this]|捕获当前对象|允许在 Lambda 内部调用当前类的成员函数（如 MyFunction()）。|
|[Val]|指定捕获|只拷贝变量 Val 进来，其他的不要。|

4. Unreal Engine 中的实战场景

场景 A：基础排序 (你的示例)

```cpp
TArray<int32> Numbers = { 5, 2, 8, 1 };
// 升序排序
Numbers.Sort([](const int32& A, const int32& B) {
    return A < B; 
});
```

场景 B：查找特定元素 (FindByPredicate)  
不想写个循环去遍历？用 Lambda 一行搞定。

```cpp
TArray<FString> Names = { TEXT("Alice"), TEXT("Bob"), TEXT("Charlie") };

// 查找名字长度大于 3 的第一个人
FString* FoundName = Names.FindByPredicate([](const FString& InName) {
    return InName.Len() > 3; // 返回 true 表示找到了
});

if (FoundName) UE_LOG(LogTemp, Log, TEXT("Found: %s"), **FoundName);
```

场景 C：延时执行 (计时器)  
这是 Lambda 最舒服的用法之一，不需要额外定义一个 TimerCallback 函数。

```cpp
// 3秒后打印一句话
FTimerHandle Handle;
GetWorld()->GetTimerManager().SetTimer(Handle, [this]() {
    // [this] 允许我们访问类成员，比如打印 Log 或调用其他函数
    UE_LOG(LogTemp, Warning, TEXT("3秒已到，Lambda 执行中！"));
    this->MyOtherFunction(); 
}, 3.0f, false);
```

场景 D：UI 事件绑定 (Slate/UMG)  
在 C++ 写 UI 逻辑时，Lambda 能极大减少代码量。

```cpp
MyButton->OnClicked.AddLambda([this]() {
    UE_LOG(LogTemp, Log, TEXT("按钮被点击了！"));
    return FReply::Handled();
});
```

5. 新手避坑指南 (重要！)

在使用 Lambda 时，最容易导致游戏崩溃的原因是生命周期问题。

危险操作：  
如果你在一个延时操作（如计时器、HTTP请求回调）中使用了 [&] 按引用捕获，或者捕获了 this 指针，但当 Lambda 执行时，原来的对象已经被销毁了，就会发生 Crash。

安全写法 (弱指针保护)：  
对于可能被销毁的 UObject，建议使用 TWeakObjectPtr。

```cpp
// 假设这是一个 Actor
TWeakObjectPtr<AActor> WeakSelf = this;

// 异步操作
RunSomeAsyncLogic([WeakSelf]() {
    // 执行时先检查对象还活着吗
    if (AActor* StrongSelf = WeakSelf.Get())
    {
        StrongSelf->SetActorLocation(FVector::ZeroVector);
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("Actor 已经没了，Lambda 安全退出"));
    }
});
```

总结  
匿名函数（Lambda） 是 C++ 给我们的一把瑞士军刀。  
短小精悍：适合写在一行里的逻辑。  
就地取材：通过捕获列表 [] 灵活使用上下文变量。  
用完即弃：保持代码整洁，不污染命名空间。

# Unreal 蓝图基础

我们c++都会了，还需要学蓝图？ 只需要简单看下蓝图编辑页面即可

# 实战

## 创建项目 & 创建文件

1. StudyCharacterBase
2. StudyHero
3. StudyGameMode
4. StudyGameState
5. StudyPlayerController
6. StudyPlayerSate

## 能看的到人物

1. 学会怎么导入Epic资源
2. 创建人物蓝图，学会 USprintComponent, UCameraComponent 两个组件

## WASD & Mouse （让人物动起来）

1. 学会增强输入，从蓝图创建InputAction，InputMappingContext，从c++ 去注册InputMappingContext，并且绑定InputAction

## Locomotion状态机（让人物动的更好看）

1. 学会Animation Blueprint，也就是动画蓝图，其中怎么获取数据，怎么写状态机，让角色在不同的状态中输出不同的动作
2. 学会 Blend Space，混合空间，他是专门混合动画用的

### 什么是状态机

就是一切状态的流转，比如跳跃，我们先起跳，然后在空中，然后落地，最后站直，这就是状态的流转

## 替换美术资源

学习万一美术资源要替换 应该怎么办

## 怪物和怪物Locomotion状态机

## 怪物AI行为树（让怪物变聪明）

1. 主要学习黑板，行为树。行为树下各个节点，Services的使用 / 还有AIController
2. 巡逻功能的实现, 学SplineComponent来指定巡逻点，但是实际他的功能更强大
3. EQS的使用，能让AI感知，比如看到敌人就跟随，然后攻击，但是此课程没有具体攻击实现

## 血条 & 血条UI展示

1. 学习自定义Component，实现 HealthComponent，这样就可以复用代码，不用再敌人主角实现两套生命功能
2. 学习 Unreal UMG，用UMG拼接UI

## 人物攻击

1. 学会overlap功能，实现伤害功能
2. 跟 血条UI 关联
3. 怪物死亡
4. 怪物Hit动作

## 可移动平台

1. 学会使用Tick 这个函数，实现自动移动平台

# 免责声明

此课程肯定有bug，并且说实话每一个功能都不是优解。但是目的只是让你更熟练的使用 c++，并且能够知道unreal中更多的知识

说白了：c++要理解并会写，unreal中更多功能只要会，不要精